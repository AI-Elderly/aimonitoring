<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Health Logs | AI Health Monitor</title>
  <link rel="stylesheet" href="styles.css" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    .table-wrapper {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      background: white;
      margin-top: 10px;
    }
    .vitals-grid {
      display: flex;
      gap: 20px;
    }
    .vital-box {
      background: #fff;
      padding: 10px;
      border-radius: 10px;
      flex: 1;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .back-btn {
      margin: 10px;
      padding: 5px 15px;
      cursor: pointer;
    }
    .nav-icon {
      width: 20px;
      vertical-align: middle;
      margin-right: 5px;
    }
    /* ESP32 Status Indicator */
    .esp32-status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.85);
      color: #0f0;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 12px;
      font-family: monospace;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }
    .esp32-status .status-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .esp32-status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #0f0;
      animation: pulse 2s infinite;
    }
    .esp32-status .dot.disconnected {
      background: #f00;
      animation: none;
    }
    .esp32-status .dot.connecting {
      background: #ff0;
      animation: blink 0.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    .esp32-toggle {
      background: #3498db;
      border: none;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.3s;
    }
    .esp32-toggle:hover {
      background: #2980b9;
    }
    .esp32-toggle.active {
      background: #27ae60;
    }
    .new-row {
      animation: highlight 2s;
    }
    @keyframes highlight {
      0% { background-color: #ffffcc; }
      100% { background-color: transparent; }
    }
  </style>
</head>
<body>

  <button class="back-btn" onclick="window.location.href='dashboard.html'">‚Üê Back</button>

  <!-- ESP32 Status Panel -->
  <div class="esp32-status" id="esp32-status">
    <div class="status-row">
      <div class="dot disconnected" id="esp32-dot"></div>
      <span id="esp32-text">ESP32: Disconnected</span>
    </div>
    <div class="status-row">
      <span id="data-status">Logs: Checking...</span>
    </div>
    <button class="esp32-toggle" id="esp32-toggle" onclick="toggleESP32()">Enable Auto-Connect</button>
  </div>

  <div class="dashboard-container">
    <aside class="sidebar">
      <h2 class="logo">BELGIUM<span>sys</span></h2>
      <nav class="nav-links">
        <a href="./dashboard.html"><img src="dashboard.png" class="nav-icon"> Dashboard</a>
        <a href="./healthlogs.html" class="active">üìã Health Logs</a>
        <a href="./settings.html">‚öôÔ∏è Settings</a>
        <a href="./device.html">üîå Device</a>
        <a href="./ai-assistant.html">
          <img src="chatbot.jpg" style="width:24px; height:24px; border-radius:50%; vertical-align:middle;">
          AlertoBot
        </a>
        <a href="./about.html">‚ÑπÔ∏è About</a>
        <a href="./signin.html">üö™ Logout</a>
      </nav>
    </aside>

    <main class="main-content">
      <header class="dashboard-header">
        <h1>Health Logs</h1>
        <p>Your recent monitoring records from ESP32 sensor</p>
      </header>

      <section class="live-vitals">
        <h2>üì° Latest Reading</h2>
        <div class="vitals-grid">
          <div class="vital-box"><h3>‚ù§Ô∏è Heart Rate</h3><p id="live-heart-rate">‚Äî</p></div>
          <div class="vital-box"><h3>üå¨Ô∏è SpO‚ÇÇ</h3><p id="live-spo2">‚Äî</p></div>
          <div class="vital-box"><h3>üïí Timestamp</h3><p id="live-timestamp">‚Äî</p></div>
        </div>
      </section>

      <section class="logs-section">
        <h2>üìã Recent Health Records</h2>
        <button id="refresh-btn">üîÑ Refresh Now</button>

        <div class="table-wrapper">
          <table class="logs-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Date</th>
                <th>Time</th>
                <th>‚ù§Ô∏è Heart Rate</th>
                <th>üå¨Ô∏è SpO‚ÇÇ</th>
              </tr>
            </thead>
            <tbody id="health-log-body">
              <tr><td colspan="5" style="text-align:center; padding:15px;">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

<!-- Background ESP32 Service -->
<script src="esp32-background-service.js"></script>

<script>
const FLASK_URL = "https://semimaterialistic-hyperbolic-laverne.ngrok-free.dev";
const token = localStorage.getItem("access_token");
const tableBody = document.getElementById("health-log-body");
const refreshBtn = document.getElementById("refresh-btn");

let pollInterval = null;
let lastRecordId = null;
let pollCount = 0;
let knownRecordIds = new Set();

const esp32Dot = document.getElementById("esp32-dot");
const esp32Text = document.getElementById("esp32-text");
const dataStatus = document.getElementById("data-status");
const esp32Toggle = document.getElementById("esp32-toggle");

// Toggle ESP32 auto-connect
function toggleESP32() {
  const status = window.ESP32BackgroundService.status();
  
  if (status.autoConnect) {
    window.ESP32BackgroundService.stop();
    esp32Toggle.textContent = "Enable Auto-Connect";
    esp32Toggle.classList.remove("active");
    esp32Text.textContent = "ESP32: Disabled";
    esp32Dot.classList.add("disconnected");
    alert("‚ùå ESP32 auto-connect disabled. Refresh page or click 'Enable' to reconnect.");
  } else {
    window.ESP32BackgroundService.start();
    esp32Toggle.textContent = "Disable Auto-Connect";
    esp32Toggle.classList.add("active");
    esp32Text.textContent = "ESP32: Connecting...";
    esp32Dot.classList.remove("disconnected");
    esp32Dot.classList.add("connecting");
    alert("‚úÖ ESP32 auto-connect enabled! Data will sync automatically in the background.");
  }
}

// Update ESP32 status indicator
setInterval(() => {
  const status = window.ESP32BackgroundService.status();
  
  if (status.connected) {
    esp32Text.textContent = `ESP32: Connected (${status.pollCount})`;
    esp32Dot.className = "dot";
  } else if (status.autoConnect) {
    esp32Text.textContent = "ESP32: Connecting...";
    esp32Dot.className = "dot connecting";
  } else {
    esp32Text.textContent = "ESP32: Disabled";
    esp32Dot.className = "dot disconnected";
  }
  
  // Update toggle button
  if (status.autoConnect) {
    esp32Toggle.textContent = "Disable Auto-Connect";
    esp32Toggle.classList.add("active");
  } else {
    esp32Toggle.textContent = "Enable Auto-Connect";
    esp32Toggle.classList.remove("active");
  }
}, 1000);

// Format date/time
function formatDateTime(ts) {
  if (!ts) return { date: "‚Äî", time: "‚Äî" };
  try {
    const utcDate = new Date(ts);
    const options = {
      timeZone: "Asia/Manila",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    };
    const formatter = new Intl.DateTimeFormat("en-PH", options);
    const parts = formatter.formatToParts(utcDate);
    const date = `${parts.find(p => p.type === "year").value}-${parts.find(p => p.type === "month").value}-${parts.find(p => p.type === "day").value}`;
    const time = `${parts.find(p => p.type === "hour").value}:${parts.find(p => p.type === "minute").value}:${parts.find(p => p.type === "second").value}`;
    return { date, time };
  } catch {
    return { date: "‚Äî", time: "‚Äî" };
  }
}

// Render table row
function renderRow(r, isNew = false) {
  const t = formatDateTime(r.timestamp);
  const rowClass = isNew ? 'class="new-row"' : '';
  return `
    <tr ${rowClass} data-id="${r.id}">
      <td>${r.id}</td>
      <td>${t.date}</td>
      <td>${t.time}</td>
      <td>${r.heart_rate ?? "‚Äî"}</td>
      <td>${r.spo2 ?? "‚Äî"}</td>
    </tr>`;
}

// Update latest vitals display
function updateLatestVitals(records) {
  if (!records.length) return;
  const r = records[0];
  document.getElementById("live-heart-rate").textContent = r.heart_rate ?? "‚Äî";
  document.getElementById("live-spo2").textContent = r.spo2 ?? "‚Äî";
  document.getElementById("live-timestamp").textContent = formatDateTime(r.timestamp).time;
}

// Fetch with cache bypass
async function fetchJSON(url, options = {}) {
  options.headers = {
    ...(options.headers || {}),
    "ngrok-skip-browser-warning": "true"
  };
  
  const randomParam = Math.random().toString(36).substring(7);
  const cacheBuster = url.includes('?') ? `&_r=${randomParam}` : `?_r=${randomParam}`;
  const finalUrl = url + cacheBuster;
  
  try {
    const res = await fetch(finalUrl, {
      ...options,
      cache: 'no-store',
      headers: options.headers
    });
    const text = await res.text();
    return { ok: res.ok, data: JSON.parse(text) };
  } catch (err) {
    return { ok: false, error: err.message };
  }
}

// Load health logs
async function loadHealthLogs() {
  pollCount++;
  dataStatus.textContent = `Logs: Checking... (${pollCount})`;
  
  if (!token) {
    tableBody.innerHTML = `<tr><td colspan="5" style="text-align:center; color:red;">‚ö†Ô∏è You must log in first.</td></tr>`;
    return;
  }

  const { ok, data, error } = await fetchJSON(`${FLASK_URL}/healthlogs`, {
    method: "GET",
    headers: { "Authorization": `Bearer ${token}` }
  });

  if (!ok) {
    tableBody.innerHTML = `<tr><td colspan="5" style="text-align:center; color:red;">‚ùå Error loading logs<br><small>${error}</small></td></tr>`;
    dataStatus.textContent = "Logs: Error";
    return;
  }

  if (!Array.isArray(data) || data.length === 0) {
    tableBody.innerHTML = `<tr><td colspan="5" style="text-align:center;">üî≠ No records found.</td></tr>`;
    dataStatus.textContent = "Logs: No data";
    return;
  }

  const latestId = data[0].id;
  
  if (lastRecordId !== null && latestId !== lastRecordId) {
    console.log(`üéâ NEW RECORD! ID: ${lastRecordId} ‚Üí ${latestId}`);
    dataStatus.textContent = `Logs: ‚úì Updated (ID: ${latestId})`;
  } else {
    dataStatus.textContent = `Logs: ‚úì Monitoring (${pollCount})`;
  }

  lastRecordId = latestId;
  
  // Update known IDs
  const oldIds = new Set(knownRecordIds);
  knownRecordIds.clear();
  data.forEach(r => knownRecordIds.add(r.id));

  // Render table with highlighting for new records
  const isFirstLoad = pollCount === 1;
  tableBody.innerHTML = data.map(r => {
    const isNewRecord = !isFirstLoad && !oldIds.has(r.id);
    return renderRow(r, isNewRecord);
  }).join("");
  
  updateLatestVitals(data);
}

// Polling control
function startPolling() {
  if (pollInterval) return;
  pollInterval = setInterval(loadHealthLogs, 2000);
}

function stopPolling() {
  if (!pollInterval) return;
  clearInterval(pollInterval);
  pollInterval = null;
}

// Visibility detection
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    stopPolling();
  } else {
    loadHealthLogs();
    startPolling();
  }
});

// Manual refresh
refreshBtn.addEventListener("click", () => {
  loadHealthLogs();
});

// Initial load
console.log("üöÄ Health logs with Background ESP32 Service loaded");
loadHealthLogs();
startPolling();
</script>
<script src="logout.js"></script>
</body>
</html>